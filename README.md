# LeetCode 刷题记录

> 用于提升个人解决编程题能力的一个项目，深入理解数据结构与算法内容。

## 📋 项目简介

本项目记录我在 LeetCode 平台上的刷题过程，包括解题思路、方法实现和代码注释。通过系统性的刷题训练，提升算法思维和编程能力。

## 🛠️ 技术栈

- **编程语言**: Java
- **开发工具**: IntelliJ IDEA
- **版本控制**: Git

## 📁 项目结构

```
LeetCode/
├── src/
│   └── main/
│       ├── Main.java          # 主入口文件
│       ├── leetcode1.java     # LeetCode 1 - 两数之和
│       ├── leetcode11.java     # LeetCode 11 - 盛最多水的容器
│       ├── leetcode15.java    # LeetCode 15 - 三数之和
│       ├── leetcode49.java    # LeetCode 49 - 字母异位词分组
│       ├── leetcode128.java   # LeetCode 128 - 最长连续序列
│       └── leetcode283.java   # LeetCode 283 - 移动零
├── out/                       # 编译输出目录
└── README.md                  # 项目说明文档
```

## 📊 刷题统计

- **总题数**: 6 题
- **简单**: 2 题
- **中等**: 4 题
- **困难**: 0 题

## 📚 已完成的题目

| 题号 | 题目名称 | 难度 | 算法标签 | 时间复杂度 | 空间复杂度 | 文件 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| [1](https://leetcode.cn/problems/two-sum/) | 两数之和 | 简单 | 数组、哈希表 | O(n) | O(n) | [leetcode1.java](src/main/leetcode1.java) |
| [11](https://leetcode.cn/problems/container-with-most-water/) | 盛最多水的容器 | 中等 | 数组、双指针、贪心 | O(n) | O(1) | [leetcode11.java](src/main/leetcode11.java) |
| [15](https://leetcode.cn/problems/3sum/) | 三数之和 | 中等 | 数组、双指针、排序 | O(n²) | O(1) | [leetcode15.java](src/main/leetcode15.java) |
| [49](https://leetcode.cn/problems/group-anagrams/) | 字母异位词分组 | 中等 | 数组、哈希表、字符串、排序 | O(nk log k) | O(nk) | [leetcode49.java](src/main/leetcode49.java) |
| [128](https://leetcode.cn/problems/longest-consecutive-sequence/) | 最长连续序列 | 中等 | 数组、哈希表、并查集 | O(n) | O(n) | [leetcode128.java](src/main/leetcode128.java) |
| [283](https://leetcode.cn/problems/move-zeroes/) | 移动零 | 简单 | 数组、双指针 | O(n) | O(1) | [leetcode283.java](src/main/leetcode283.java) |

### 题目详情

#### [1. 两数之和](src/main/leetcode1.java)
- **问题描述**: 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。
- **解题思路**: 使用哈希表存储已遍历的元素及其索引，在遍历过程中查找是否存在 `target - nums[i]`。
- **关键点**: 一次遍历即可完成，时间复杂度优化到 O(n)。

#### [11. 盛最多水的容器](src/main/leetcode11.java)
- **问题描述**: 给定一个长度为 n 的整数数组 `height`。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i])。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
- **解题思路**: 使用双指针技巧，从数组两端开始，每次移动高度较小的指针。因为容器的面积由较短的边决定，移动较短的边才有可能获得更大的面积。
- **关键点**: 
  - 双指针从两端向中间移动
  - 每次移动高度较小的指针
  - 贪心策略：总是保留较高的边，移动较短的边
  - 时间复杂度 O(n)，空间复杂度 O(1)

#### [15. 三数之和](src/main/leetcode15.java)
- **问题描述**: 给你一个整数数组 `nums`，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k`，同时还满足 `nums[i] + nums[j] + nums[k] == 0`。请你返回所有和为 0 且不重复的三元组。
- **解题思路**: 
  1. 首先对数组进行排序
  2. 固定第一个数 `a`，将问题转化为在剩余数组中找两数之和等于 `-a`
  3. 使用双指针在排序后的数组中查找，左指针从 `a` 的下一位开始，右指针从数组末尾开始
  4. 跳过重复元素以避免重复的三元组
- **关键点**: 
  - 排序是去重的基础
  - 双指针技巧将时间复杂度从 O(n³) 优化到 O(n²)
  - 需要仔细处理重复元素的情况
  - 时间复杂度 O(n²)，空间复杂度 O(1)（不考虑返回结果的空间）

#### [49. 字母异位词分组](src/main/leetcode49.java)
- **问题描述**: 给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。
- **解题思路**: 
  - **方法一（排序法）**: 将每个字符串排序后作为哈希表的键，相同键的字符串归为一组。时间复杂度 O(nk log k)，其中 n 是字符串数量，k 是字符串最大长度。
  - **方法二（计数法）**: 统计每个字符串中每个字符的出现次数，将计数结果作为键。时间复杂度 O(nk)，空间复杂度更优。
- **关键点**: 如何设计哈希表的键是关键，两种方法各有优劣。

#### [128. 最长连续序列](src/main/leetcode128.java)
- **问题描述**: 给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。要求时间复杂度为 O(n)。
- **解题思路**: 使用哈希集合存储所有数字，然后遍历集合，对于每个数字，如果它是某个连续序列的起点（即不存在 `num-1`），则从该数字开始向后查找连续序列的长度。
- **关键点**: 
  - 使用哈希集合实现 O(1) 的查找
  - 只从序列的起点开始查找，避免重复计算
  - 虽然有两层循环，但每个数字最多被访问两次，总体时间复杂度为 O(n)

#### [283. 移动零](src/main/leetcode283.java)
- **问题描述**: 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
- **解题思路**: 使用双指针技巧，`left` 指针指向下一个非零元素应该放置的位置，`right` 指针遍历数组。
- **关键点**: 原地操作，不需要额外空间，时间复杂度 O(n)。

## 🚀 如何运行

### 方式一：使用 IntelliJ IDEA（推荐）

1. 打开项目
2. 找到要运行的 Java 文件（如 `leetcode1.java`）
3. 点击 `main` 方法左侧的绿色运行按钮
4. 或使用快捷键：`Ctrl+Shift+R` (Mac) / `Ctrl+Shift+F10` (Windows/Linux)

### 方式二：使用命令行

```bash
# 编译
javac -d out/production/LeetCode src/main/leetcode1.java

# 运行
java -cp out/production/LeetCode main.leetcode1
```

## 📝 刷题计划

- [x] 两数之和 (LeetCode 1)
- [x] 盛最多水的容器 (LeetCode 11)
- [x] 三数之和 (LeetCode 15)
- [x] 字母异位词分组 (LeetCode 49)
- [x] 最长连续序列 (LeetCode 128)
- [x] 移动零 (LeetCode 283)
- [ ] 更多题目持续更新中...

## 📖 学习笔记

记录解题过程中的思考：
- 算法思路分析
- 时间复杂度与空间复杂度分析
- 边界条件处理
- 代码优化技巧
- 多种解法的对比与选择

## 🔍 算法标签统计

- **哈希表**: 3 题（1, 49, 128）
- **数组**: 6 题（1, 11, 15, 49, 128, 283）
- **双指针**: 3 题（11, 15, 283）
- **字符串**: 1 题（49）
- **排序**: 2 题（15, 49）
- **并查集**: 1 题（128）
- **贪心**: 1 题（11）

## 🤝 贡献

欢迎提出建议和问题！

## 📄 许可证

本项目仅用于个人学习，不做商业用途。

---

**持续更新中...** 🚀
